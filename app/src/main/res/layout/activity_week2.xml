<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".week1"
    android:background="@drawable/gradient_background">

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical" > SHOULD BE BOLD)
            android:textColor="#000000"

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="A Java Program"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="All Java applications have a similar basic structure. Despite its small size and simple purpose, this program contains several important features. Let’s carefully dissect it and examine its pieces."
                android:layout_margin="16dp"
                android:textColor="#000000"
                android:textSize="18sp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The first few lines of the program are comments, which start with the // symbols and continue to the end of the line. Comments don’t affect what the program does but are included to make the program easier to understand by humans. Programmers can and should include comments as needed throughout a program to clearly identify the purpose of the program and describe any special processing. Any written comments or documents, including a user’s guide and technical references, are called documentation. Comments included in a program are called inline documentation."
                android:layout_margin="16dp"
                android:textColor="#000000"
                android:textSize="18sp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The rest of the program is a class definition. This class is called Lincoln, though we could have named it just about anything we wished. The class definition runs from the first opening brace ({) to the final closing brace (}) on the last line of the program. All Java programs are defined using class definitions."
                android:layout_margin="16dp"
                android:textColor="#000000"
                android:textSize="18sp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Inside the class definition are some more comments describing the purpose of the main method, which is defined directly below the comments. A method is a group of programming statements that is given a name. In this case, the name of the method is main and it contains only two programming statements. Like a class definition, a method is also delimited by braces."
                android:layout_margin="16dp"
                android:textColor="#000000"
                android:textSize="18sp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image5"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="All Java applications have a main method, which is where processing begins. Each programming statement in the main method is executed, one at a time in order, until the end of the method is reached. Then the program ends, or terminates. The main method definition in a Java program is always preceded by the words public, static, and void, which we examine later in the text. The use of String and args does not come into play in this particular program. We describe these later also."
                android:layout_margin="16dp"
                android:textColor="#000000"
                android:textSize="18sp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The two lines of code in the main method invoke another method called println (pronounced print line). We invoke, or call, a method when we want it to execute. The println method prints the specified characters to the screen. The characters to be printed are represented as a character string, enclosed in double quote characters(''). When the program is executed, it calls the println method to print the first statement, calls it again to print the second statement, and then, because that is the last line in the main method, then the program terminates."
                android:layout_margin="16dp"
                android:textColor="#000000"
                android:textSize="18sp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The code executed when the println method is invoked is not defined in this program. The println method is part of the System.out object, which is part of the Java standard class library. It’s not technically part of the Java language."
                android:layout_margin="16dp"
                android:textColor="#000000"
                android:textSize="18sp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Coding Guidelines"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="A series of conventions that describe how programs should be constructed. They make programs easier to read, exchange, and integrate. Sometimes referred to as coding standards, especially when they are enforced."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Overriding Methods"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="When a child class defines a method with the same name and signature as a method in the parent class, we say that the child’s version overrides the parent’s version in favor of its own. The need for overriding occurs often in inheritance situations."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The program in Listing 8.7 provides a simple demonstration of method overriding in Java. The Messages class contains a main method that instantiates two objects: one from class Thought and one from class Advice. The Thought class is the parent of the Advice class."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Both the Thought class (shown in Listing 8.8 on page 386) and the Advice class (shown in Listing 8.9 on page 387) contain a definition for a method called message. The version of message defined in the Thought class is inherited by Advice, but Advice overrides it with an alternative version. The new version of the method prints out an entirely different message and then invokes the parent’s version of the message method using the super reference."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The object that is used to invoke a method determines which version of the method is actually executed. When message is invoked using the parked object in the main method, the Thought version of message is executed. When message is invoked using the dates object, the Advice version of message is executed."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image6"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="A method can be defined with the final modifier. A child class cannot override a final method. This technique is used to ensure that a derived class uses a particular definition of a method."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Method overriding is a key element in object-oriented design. It allows two objects that are related by inheritance to use the same naming conventions for methods that accomplish the same general task."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="A Stack Collection"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"
                android:textStyle="bold" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="A stack is a linear collection whose elements are added and removed from the same end. We say that a stack is processed in a last in, first out (LIFO) manner. That is, the last element to be put on a stack will be the first one that gets removed. Said another way, the elements of a stack are removed in the reverse order of their placement on it. In fact, one of the principle uses of a stack in computing is to reverse the order of something (e.g., an undo operation)."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The processing of a stack is shown in Figure 14.2. Usually a stack is depicted vertically, and we refer to the end to which elements are added and from which they are removed as the top of the stack."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image7"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Recall from our earlier discussions that we define an abstract data type (ADT) by identifying a specific set of operations that establishes the valid ways in which we can manage the elements stored in the data structure. We always want to use this concept to formally define the operations for a collection and work within the functionality it provides. That way, we can cleanly separate the interface to the collection from any particular implementation technique used to create it."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The operations for a stack ADT are listed in Figure 14.3. In stack terminology, we push an element onto a stack and we pop an element off a stack. We can also peek at the top element of a stack, examining it or using it as needed, without actually removing it from the collection. There are also the general operations that allow us to determine if the stack is empty and, if not empty, how many elements it contains."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Sometimes there are variations on the naming conventions for the operations on a collection. For a stack, the use of the terms push and pop are relatively standard. The peek operation is sometimes referred to as top."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Keep in mind that the definition of a collection is not universal. You will find variations in the operations defined for specific data structures from one book to another. We’ve been very careful in this book to define the operations on each collection so that they are consistent."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="For example, note that none of the stack operations in Figure 14.3 allow us to reach down into the stack to modify, remove, or reorganize the elements in the stack. That is the very nature of a stack—all activity occurs at one end. If we discover that, to solve a particular problem, we need to access the elements in the middle or at the bottom of the collection, then a stack is not the appropriate data structure to use."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="We do provide a toString operation for the collection. This is not a classic operation defined for a stack, and it could be argued that this operation violates"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image8"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="the prescribed behavior of a stack. However, it provides a convenient means to traverse and display the stack’s contents without allowing modification of the stack and this is quite useful for debugging purposes."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="A Queue ADT"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="A queue is a linear collection whose elements are added on one end and removed from the other. Therefore, we say that queue elements are processed in a first in, first out (FIFO) manner. Elements are removed from a queue in the same order."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="This is consistent with the general concept of a waiting line. When a customer arrives at a bank, he or she begins waiting at the end of the line. When a teller becomes available, the customer at the beginning of the line leaves the line to receive service. Eventually every customer that started out at the end of the line moves to the front of the line and exits. For any given set of people, the first person to get in line is the first person to leave it."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The processing of a queue is pictured in Figure 15.1. Usually a queue is depicted horizontally. One end is established as the front of the queue and the other as the rear of the queue. Elements go onto the rear of the queue and come off of the front. Sometimes the front of the queue is called the head and the rear of the queue the tail."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Compare and contrast the processing of a queue to the LIFO (last in, first out) processing of a stack. In a stack, the processing occurs at only one end of the collection. In a queue, processing occurs at both ends."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The operations defined for a queue ADT are listed in Figure 15.2. The term enqueue is used to refer to the process of adding a new element to the end of a queue. Likewise, dequeue refers to removing the element at the front of a queue. The first operation allows the user to examine the element at the front of the queue without removing it from the collection."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Remember that naming conventions are not universal for collection operations. Sometimes enqueue is simply called add or insert. The dequeue operation is sometimes called remove or serve. The first operation is sometimes called front."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image9"
                android:layout_gravity="center"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image10"
                android:layout_gravity="center"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Note that there is a general similarity between the operations of a queue and those of a stack. The enqueue, dequeue, and first operations correspond to the stack operations push, pop, and peek. Similar to a stack, there are no operations that allow the user to “reach into” the middle of a queue and reorganize or remove elements. If that type of processing is required, perhaps the appropriate collection to use is a list of some kind."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="As we did with stacks, we define a generic Queue interface that represents the queue operations, separating the general purpose of the operations from the variety of ways they could be implemented."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image11"
                android:layout_gravity="center"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image12"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Note that in addition to the standard queue operations, we have also included a toString method, as we did with our stack collection. It is included for convenience and is not generally considered a classic operation on a queue."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Queues have a wide variety of application within computing. Whereas the principle purpose of a stack is to reverse order, the principle purpose of a queue is to preserve order. Before exploring various ways to implement a queue, let’s examine some ways in which a queue can be used to solve problems."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Comments"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Comments are the only language feature that allows programmers to compose and communicate their thoughts independent of the code. Comments should provide insight into the programmer’s original intent. A program is often used for many years, and often many modifications are made to it over time. The original programmer often will not remember the details of a particular program when, at some point in the future, modifications are required. Furthermore, the original programmer is not always available to make the changes; thus, someone completely unfamiliar with the program will need to understand it. Good documentation is therefore essential."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="As far as the Java programming language is concerned, the content of comments can be any text whatsoever. Comments are ignored by the computer; they do not affect how the program executes."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The comments in the Lincoln program represent one of two types of comments allowed in Java. The comments in Lincoln take the following form:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:id="@+id/imageView"
                android:src="@drawable/image13"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="This type of comment begins with a double slash (//) and continues to the end of the line. You cannot have any characters between the two slashes. The computer ignores any text after the double slash to the end of the line. A comment can follow code on the same line to document that particular line, as in the following example:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image14"
                android:layout_gravity="center" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The second form a Java comment may have is the following:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="This comment type does not use the end of a line to indicate the end of the comment. Anything between the initiating slash-asterisk (/*) and the terminating asterisk-slash (*/) is part of the comment, including the invisible newline character that represents the end of a line. Therefore, this type of comment can extend over multiple lines. No space can be between the slash and the asterisk."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="If there is a second asterisk following the /* at the beginning of a comment, the content of the comment can be used to automatically generate external documentation about your program by using a tool called javadoc."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The two basic comment types can be used to create various documentation styles, such as:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image15"
                android:layout_gravity="center" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Programmers often concentrate so much on writing code that they focus too little on documentation. You should develop good commenting practices and follow them habitually. Comments should be well written, often in complete sentences. They should not belabor the obvious but should provide appropriate insight into the intent of the code. The following examples are not good comments:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image16"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The first comment paraphrases the obvious purpose of the line and does not add any value to the statement. It is better to have no comment than a useless one. The second comment is ambiguous."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Identifiers and Reserved Words"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The various words used when writing programs are called identifiers. The identifiers in the Lincoln program are class, Lincoln, public, static, void, main, String, args, System, out, and println. These fall into three categories:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="■ words that we make up when writing a program (Lincoln and args)"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="■ words that another programmer chose (String, System, out, println, and main)"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="■ words that are reserved for special purposes in the language (class, public, static, and void)"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="While writing the program, we simply chose to name the class Lincoln, but we could have used one of many other possibilities. For example, we could have called it Quote, or Abe, or GoodOne. The identifier args (which is short for arguments) is"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image17"
                android:layout_gravity="center" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="often used in the way we use it in Lincoln, but we could have used just about any other identifier in its place."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The identifiers String, System, out, and println were chosen by other programmers. These words are not part of the Java language. They are part of the Java standard library of predefined code, a set of classes and methods that someone has already written for us. The authors of that code chose the identifiers in that code—we’re just making use of them."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Reserved words are identifiers that have a special meaning in a programming language and can only be used in predefined ways. A reserved word cannot be used for any other purpose, such as naming a class or method. In the Lincoln program, the reserved words used are class, public, static, and void. Figure 1.1 lists all of the Java reserved words in alphabetical order. The words marked with an asterisk are reserved for possible future use in later versions of the language but currently have no meaning in Java."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="An identifier that we make up for use in a program can be composed of any combination of letters, digits, the underscore character (_), and the dollar sign ($), but it cannot begin with a digit. Identifiers may be of any length. Therefore, total, label7, nextStockItem, NUM_BOXES, and $amount are all valid identifiers, but 4th_word and coin#value aren't valid."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Both uppercase and lowercase letters can be used in an identifier, and the difference is important. Java is case sensitive, which means that two identifier names that differ only in the case of their letters are considered to be different identifiers. Therefore, total, Total, ToTaL, and TOTAL are all different identifiers. As you can imagine, it is not a good idea to use multiple identifiers that differ only in their case, because they can be easily confused."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image18"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Although the Java language doesn’t require it, using a consistent case format for each kind of identifier makes your identifiers easier to understand. There are various Java conventions regarding identifiers that should be followed, though technically they don’t have to be. For example, we use title case (uppercase for the first letter of each word) for class names. Throughout the text, we describe the preferred case style for each type of identifier when it is first encountered."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="While an identifier can be of any length, you should choose your names carefully. They should be descriptive but not verbose. You should avoid meaningless names such as a or x. An exception to this rule can be made if the short name is actually descriptive, such as using x and y to represent (x, y) coordinates on a two-dimensional grid. Likewise, you should not use unnecessarily long names, such as the identifier theCurrentItemBeingProcessed. The name currentItem would serve just as well. As you might imagine, the use of identifiers that are verbose is a much less prevalent problem than the use of names that are not descriptive."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="You should always strive to make your programs as readable as possible. Therefore, you should always be careful when abbreviating words. You might think curStVal is a good name to represent the current stock value, but another person trying to understand the code may have trouble figuring out what you meant. It might not even be clear to you two months after writing it."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="A name in Java is a series of identifiers separated by the dot (period) character. The name System.out is the way we designate the object through which we invoked the println method. Names appear are quite regularly in Java programs."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="White Space"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="All Java programs use white space to separate the words and symbols used in a program. White space consists of blanks, tabs, and newline characters. The phrase white space refers to the fact that, on a white sheet of paper with black printing, the space between the words and symbols is white. The way a programmer uses white space is important because it can be used to emphasize parts of code and can make program easier to read."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Except when it’s used to separate words, the computer ignores white space. It does not affect the execution of a program. This fact gives programmers a great deal of flexibility in how they format a program. The lines of a program should be divided in logical places and certain lines should be indented and aligned so that the program’s underlying structure is clear."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Because white space is ignored, we can write a program in many different ways. For example, taking white space to one extreme, we could put as many words as possible on each line. The code in Listing 1.2, the Lincoln2 program, is formatted quite differently from Lincoln but prints the same message."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image19"
                android:layout_gravity="center"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Variables"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="A variable is a name for a location in memory used to hold a data value. A variable declaration instructs the compiler to reserve a portion of main memory"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image20"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="space large enough to hold a particular type of value and indicates the name by which we refer to that location."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Consider the program PianoKeys, shown in Listing 2.5 on the next page. The first line of the main method is the declaration of a variable named keys that holds an integer (int) value. The declaration also gives keys an initial value of 88. If an initial value is not specified for a variable, the value is undefined. Most Java compilers give errors or warnings if you attempt to use a variable before you’ve explicitly given it a value. "
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The keys variable, with its value, could be pictured as follows:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image21"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="In the PianoKeys program, two pieces of information are used in the call to the println method. The first is a string, and the second is the variable keys. When a variable is referenced, the value currently stored in it is used. Therefore, when the call to println is executed, the value of keys, which is 88 which is obtained."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image22"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Because that value is an integer, it is automatically converted to a string and concatenated with the initial string. The concatenated string that is passed to println and printed."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="A variable declaration can have multiple variables of the same type declared on one line. Each variable on the line can be declared with or without an initializing value. For example:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image23"
                android:layout_gravity="center"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The Assignment Statement"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Let’s examine a program that changes the value of a variable. Listing 2.6 shows a program called Geometry. This program first declares an integer variable called sides and initializes it to 7. It then prints out the current value of sides."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>


            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image24"
                android:layout_gravity="center"
                />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The next line in main changes the value stored in the variable sides"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>


            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image25"
                android:layout_gravity="center" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="This is called an assignment statement because it assigns a value to a variable. When executed, the expression on the right-hand side of the assignment operator (=) is evaluated, and the result is stored in the memory location indicated by the variable on the left-hand side. In this example, the expression is simply a number, 10. We discuss expressions that are more involved than this in the next section."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>


            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image26"
                android:layout_gravity="center" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="A variable can store only one value of its declared type. A new value overwrites the old one. In this case, when the value 10 is assigned to sides, the original value 7 is overwritten and lost forever, as follows:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image27"
                android:layout_gravity="center" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="When a reference is made to a variable, such as when it is printed, the value of the variable is not changed. This is the nature of computer memory: Accessing (reading) data leaves the values in memory intact, but writing data replaces the old data with the new."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The Java language is strongly typed, meaning that we are not allowed to assign a value to a variable that is inconsistent with its declared type. Trying to combine incompatible types will generate an error when you attempt to compile the program. Therefore, the expression on the right-hand side of an assignment statement must evaluate to a value compatible with the type of the variable on the lefthand side."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Constants"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Sometimes we use data that is constant throughout a program. For instance, we might write a program that deals with a theater that can hold no more than 427 people. It is often helpful to give a constant value a name, such as MAX_OCCUPANCY, instead of using a literal value, such as 427, throughout the code. The purpose and meaning of literal values such as 427 is often confusing to someone reading the code. By giving the value a name, you help explain its role in the program."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Constants are identifiers and are similar to variables except that they hold a particular value for the duration of their existence. Constants are, to use the English meaning of the words, not variable. Their value does not change."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="In Java, if you precede a declaration with the reserved word final, the identifier is made a constant. By convention, uppercase letters are used when naming constants to distinguish them from regular variables, and individual words are separated using the underscore character. For example, the constant describing the maximum occupancy of a theater could be declared as follows:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image28"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The compiler will produce an error message if you attempt to change the value of a constant once it has been given its initial value. This is another good reason to use constants. Constants prevent inadvertent coding errors because the only valid place to change their value is in the initial assignment."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="There is a third good reason to use constants. If a constant is used throughout a program and its value needs to be modified, then you have to change it in only one place. For example, if the capacity of the theater changes (because of a renovation) from 427 to 535, then you have to change only one declaration, and all uses of MAX_OCCUPANCY automatically reflect the change. If the literal 427 had been used throughout the code, each use would have to be found and changed. If you were to miss any uses of the literal value, problems that would surely arise."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Primitive Data Types"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="There are eight primitive data types in Java: four subsets of integers, two subsets of floating point numbers, a character data type, and a boolean data type. Everything else is represented using objects. Let’s examine these eight primitive data types in some detail"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Integers and Floating Points"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Java has two basic kinds of numeric values: integers, which have no fractional part, and floating points, which do. There are four integer data types (byte,"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image29"
                android:layout_gravity="center" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="short, int, and long) and two floating point data types (float and double). All of the numeric types differ by the amount of memory space used to store a value of that type, which determines the range of values that can be represented. The size of each data type is the same for all hardware platforms. All numeric types are signed, meaning that both positive and negative values can be stored in them. Figure 2.2 summarizes numeric primitive types."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="A bit, or binary digit, can be either a 1 or a 0. Because each bit can represent two different states, a string of N bits can be used to represent 2N different values."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="When designing programs, we sometimes need to be careful about picking variables of appropriate size so that memory space is not wasted. This occurs in situations where memory space is particularly restricted, such as a program that runs on a personal data assistant (PDA). In such cases, we can choose a variable’s data type accordingly. For example, if the value of a particular variable will not vary outside of a range of 1 to 1000, then a two-byte integer (short) is large enough to accommodate it. On the other hand, when it’s not clear what the range of a particular variable will be, we should provide a reasonable, even generous, amount of space. In most situations memory space is not a serious restriction, and we can usually afford generous assumptions."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Note that even though a float value supports very large (and very small) numbers, it only has seven significant digits. Therefore, if it is important to accurately maintain a value such as 50341.2077, we need to use a double."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="PianoKeys are all integer literals. Java assumes all integer literals are of type int, unless an L or l is appended to the end of the value to indicate that it should be considered a literal of type long, such as 45L."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Likewise, Java assumes that all floating point literals are of type double. If we need to treat a floating point literal as a float, we append an F or f to the end of the value, as in 2.718F or 123.45f. Numeric literals of type double can be followed by a D or d if desired."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The following are examples of numeric variable declarations in Java:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image30"
                android:layout_gravity="center"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Characters"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Characters are another fundamental type of data used and managed on a computer. Individual characters can be treated as separate data items, and, as we’ve seen in several examples, they can be combined to form character strings."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="A character literal is expressed in a Java program with single quotes, such as 'b' or 'J' or ';'. You will recall that string literals are delineated using double quotation marks, and that the String type is not a primitive data type in Java, it is a class name."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Note the difference between a digit as a character (or part of a string) and a digit as a number (or part of a larger number). The number 602 is a numeric"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image31"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="value that can be used in an arithmetic calculation. But in the string '602 Greenbriar Court' the 6, 0, and 2 are characters, just like the rest of characters that make up string."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The characters we can manage are defined by a character set, which is simply a list of characters in a particular order. Each programming language supports a particular character set that defines the valid values for a character variable in that language. Several character sets have been proposed, but only a few have been used regularly over the years. The ASCII character set is a popular choice. ASCII stands for the American Standard Code for Information Interchange. The basic ASCII set uses 7 bits per character, providing room to support 128 different characters, including:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="■ uppercase letters, such as 'A', 'B', and 'C' "
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="■ lowercase letters, such as 'a', 'b', and 'c' "
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="■ punctuation, such as the period ('.'), semicolon (';'), and comma (',') "
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="■ the digits '0' through '9' "
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="■ the space character, ' ' "
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="■ special symbols, such as the ampersand, vertical bar ('|'), and backslash ('\') "
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="■ control characters, such as the carriage return, null, and end-of-text marks"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The control characters are sometimes called nonprinting or invisible characters because they do not have a specific symbol that represents them. Yet they are as valid as any other character and can be stored and used in the same ways. Many control characters have special meaning to certain software applications."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="As computing became a worldwide endeavor, users demanded a more flexible character set containing other language alphabets. ASCII was extended to use 8 bits per character, and the number of characters in the set doubled to 256. The extended ASCII contains many accented and diacritical characters used in languages other than English"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="However, even with 256 characters, the ASCII character set cannot represent the world’s alphabets, especially given the various Asian alphabets and their many thousands of ideograms. Therefore, the developers of the Java programming language chose the Unicode character set, which uses 16 bits per character, supporting 65,536 unique characters. The characters and symbols from many languages are included in the Unicode definition. ASCII is a subset of the Unicode character set. Appendix C discusses the Unicode character set in more detail."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="A character set assigns a particular number to each character, so by definition the characters are in a particular order. This is referred to as lexicographic order. In the ASCII and Unicode ordering, the digit characters '0' through '9' are continuous (no other characters intervene) and in order. Similarly, the lowercase alphabetic characters 'a' through 'z' are continuous and in order, as are the uppercase alphabetic characters 'A' through 'Z'. These characteristics make it relatively easy to sort data, such as a list of names, in alphabetical order."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="In Java, the data type char represents a single character. The following are some examples of character variable declarations in Java:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image32"
                android:layout_gravity="center" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Booleans"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="A boolean value, defined in Java using the reserved word boolean, has only two valid values: true and false. A boolean variable is usually used to indicate whether a particular condition is true, but it can also be used to represent any situation that has two states, such as a light bulb being on or off. The term boolean is named in honor of English mathematician George Boole, who developed a form of algebra (Boolean algebra) in which variables take on only one of two values."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="A boolean value cannot be converted to any other data type, nor can any other data type be converted to a boolean value. The words true and false are reserved in Java as boolean literals and that cannot be used outside of this context."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The following are some examples of boolean variable declarations in Java:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image33"
                android:layout_gravity="center"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Expressions"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="An expression is a combination of one or more operators and operands that usually performs a calculation. The value calculated does not have to be a number, but often is. The operands used in the operations might be literals, constants, variables, or other sources of data. The manner in which expressions are evaluated and used is fundamental to programming. For now we will focus on arithmetic expressions that use numeric operands and that produce numeric results."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Arithmetic Operators"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The usual arithmetic operations are defined for both integer and floating point numeric types, including addition (+), subtraction (–), multiplication (*), and division (/). Java also has another arithmetic operation: The remainder operator (%) returns the remainder after dividing the second operand into the first. The remainder operator is sometimes called the modulus operator. The sign of the result of a remainder operation is the sign of the numerator. This table shows some examples:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image34"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="As you might expect, if either or both operands to any numeric operator are floating point values, the result is a floating point value. However, the division operator (/) produces results that are less intuitive, depending on the types of the operands. If both operands are integers, the / operator performs integer division, meaning that any fractional part of the result is discarded. If one or the other or both operands are floating point values, the / operator performs floating point division, and the fractional part of the result is kept. For example, the result of 10/4 is 2, but the results of 10.0/4 and 10/4.0 and 10.0/4.0 are all 2.5."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="A unary operator has only one operand, while a binary operator has two. The + and – arithmetic operators can be either unary or binary. The binary versions accomplish addition and subtraction, and the unary versions represent positive and negative numbers. For example, –1 is an example of using the unary negation operator to make the value negative. The unary + operator is rarely used."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Java does not have a built-in operator for raising a value to an exponent. However, the Math class provides methods that perform exponentiation and other mathematical functions."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Operator Precedence"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Operators can be combined to create more complex expressions. For example, consider the following assignment statement:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image35"
                android:layout_gravity="center" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The entire right-hand side of the assignment is evaluated, and then the result is stored in the variable. But what is the result? If the addition is performed first, the result is 11; if the division operation is performed first, the result is 18. The order of operator evaluation makes a big difference. In this case, the division is performed before the addition, yielding a result of eighteen."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Note that in this and subsequent examples, we use literal values rather than variables to simplify the expression. The order of operator evaluation is the same if the operands are variables or any other source of data."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="All expressions are evaluated according to an operator precedence hierarchy that establishes the rules that govern the order in which operations are evaluated. The arithmetic operators generally follow the same rules you learned in algebra. Multiplication, division, and the remainder operator all have equal precedence and are performed before (have higher precedence than) addition and subtraction. Addition and subtraction have equal precedence."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Any arithmetic operators at the same level of precedence are performed left to right. Therefore we say the arithmetic operators have a left-to-right association."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Precedence, however, can be forced in an expression by using parentheses. For instance, if we really wanted the addition to be performed first in the previous example, we could write the expression as follows:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image36"
                android:layout_centerVertical="true"
                android:layout_centerHorizontal="true"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Any expression in parentheses is evaluated first. In complicated expressions, it is good practice to use parentheses even when it is not strictly necessary, to make it clear how the expression is evaluated."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Parentheses can be nested, and the innermost nested expressions are evaluated first. Consider the following expression:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image37"
                android:layout_gravity="center" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="In this example, the result is 21. First, the subtraction is performed, forced by the inner parentheses. Then, even though multiplication and division are at the same level of precedence and usually would be evaluated left to right, the division is performed first because of the outer parentheses. Finally, the multiplication is performed."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="After the arithmetic operations are complete, the computed result is stored in the variable on the left-hand side of the assignment operator (=). In other words, the assignment operator has a lower precedence than any of the arithmetic operators."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The evaluation of a particular expression can be shown using an expression tree, such as the one in Figure 2.3. The operators are executed from the bottom up, creating values that are used in the rest of the expression. Therefore, the operations"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image38"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="lower in the tree have a higher precedence than those above, or they are forced to be executed earlier using parentheses."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The parentheses used in expressions are actually operators themselves. Parentheses have a higher precedence than almost any other operator. Figure 2.4 shows a precedence table with the relationships between the arithmetic operators, parentheses, and the assignment operator."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="For an expression to be syntactically correct, the number of left parentheses must match the number of right parentheses and they must be properly nested. The following examples are not valid expressions:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image39"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Keep in mind that when a variable is referenced in an expression, its current value is used to perform the calculation. In the following assignment statement, the current value of the variable count is added to the current value of the variable total, and the result is stored in the variable sum:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image40"
                android:layout_gravity="center"
                />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The original value contained in sum before this assignment is overwritten by the calculated value. The values stored in count and total are not changed.The original value contained in sum before this assignment is overwritten by the calculated value. The values stored in count and total are not changed."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The same variable can appear on both the left-hand side and the right-hand side of an assignment statement. Suppose the current value of a variable called count is 15 when the following assignment statement is executed:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image41"
                android:layout_gravity="center" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Because the right-hand expression is evaluated first, the original value of count is obtained and the value 1 is added to it, producing the result 16. That result is then stored in the variable count, overwriting the original value of 15 with the new value of 16. Therefore, this assignment statement increments, or adds one to, the variable count."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Let’s look at another example of expression processing. The program in Listing 2.7 on the next page, called TempConverter, converts a particular Celsius temperature value to equivalent Fahrenheit value using expression that computes the following formula:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image42"
                android:layout_gravity="center" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Note that in the TempConverter program, the operands to the division operation are floating point literals to ensure that the fractional part of the number is kept. The precedence rules dictate that the multiplication happens before the addition in the final conversion computation."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The TempConverter program is not very useful because it converts only one data value that we included in the program as a constant (24 degrees Celsius). Every time the program is run it produces the same result. A far more useful version of the program would obtain the value to be converted from the user each time the program is executed. "
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Increment and Decrement Operators"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="There are two other useful arithmetic operators. The increment operator (++) adds 1 to any integer or floating point value. The two plus signs that make up the operator cannot be separated by white space. The decrement operator (--) is sim"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image43"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="except that it subtracts 1 from the value. They are both unary operators because they operate on only one operand. The following statement causes the value of count to be incremented:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image44"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The result is stored back into the variable count. Therefore it is functionally equivalent to the following statement, which we discussed in the previous section:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image45"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The increment and decrement operators can be applied after the variable (such as count++ or count--), creating what is called the postfix form of the operator. They can also be applied before the variable (such as ++count or --count), in what is called the prefix form. When used alone in a statement, the prefix and postfix forms are functionally equivalent. That is, it does not matter if you write"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image46"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="However, when such a form is written as a statement by itself, it is usually written in its postfix form."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="When the increment or decrement operator is used in a larger expression, it can yield different results depending on the form used. For example, if the variable count currently contains the value 15, the following statement assigns the value 15 to total and the value 16 to count:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image47"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="However, if count contains 15, with the following statement that assigns the value 16 to both total and count:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image48"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The value of count is incremented in both situations, but the value used in the larger expression depends on whether a prefix or postfix form of the increment operator is used."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Because of the subtle differences between the prefix and postfix forms of the increment and decrement operators, they should be used with care. As always, favor the side of readability."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Assignment Operators"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="As a convenience, several assignment operators have been defined in Java that combine a basic operation with assignment. For example, and the += operator can be used as follows:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image49"
                android:layout_gravity="center"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="This performs the same operation as with the following statement:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image50"
                android:layout_gravity="center" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The right-hand side of the assignment operator can be a full expression. The expression on the right-hand side of the operator is evaluated, then that result added to the current value of the variable on the left-hand side, and that value is stored in the variable. Therefore, the following statement:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image51"
                android:layout_gravity="center" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Many similar assignment operators are defined in Java, including those that perform subtraction (-=), multiplication (*=), division (/=), and remainder (%=). "
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="All of the assignment operators evaluate the entire expression on the righthand side first, then use the result as the right operand of the other operation. Therefore, the following statement:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>


            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image52"
                android:layout_gravity="center" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Some assignment operators perform particular functions depending on the types of the operands, just as their corresponding regular operators do. For example, if the operands to the += operator are strings, then the assignment operator performs string concatenation."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Casting"
                android:textColor="#000000"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Casting is the most general form of conversion in Java. If a conversion can be accomplished at all in a Java program, it can be accomplished using a cast. A cast is a Java operator that is specified by a type name in parentheses. It is placed in front of the value to be converted. For example, to convert money to an integer value, we could put a cast in front of it:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image53"
                android:layout_gravity="center" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The cast returns the value in money, truncating any fractional part. If money contained the value 84.69, then after the assignment, dollars would contain the value 84. Note, however, that the cast does not change the value in money. After the assignment operation is complete, money still contains the value 84.69."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Casts are helpful in many situations where we need to treat a value temporarily as another type. For example, if we want to divide the integer value total by the integer value count and get a floating point result, as we could do it as follows:"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image54"
                android:layout_gravity="center" />

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="First, the cast operator returns a floating point version of the value in total. This operation does not change the value in total. Then, count is treated as a floating point value via arithmetic promotion. Now the division operator will perform floating point division and produce the intended result. If the cast had not been included, the operation would have performed integer division and truncated the answer before assigning it to result. Also note that because the cast operator has a higher precedence than the division operator, the cast operates on the value of total, not on the result of the division."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The Decimal Formal Class"
                android:textSize="20sp"
                android:layout_margin="16dp"
                android:textStyle="bold"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Unlike the NumberFormat class, the DecimalFormat class is instantiated in the traditional way using the new operator. Its constructor takes a String parameter that represents the pattern that will guide the formatting process. We can then use the format method to format a particular value. At a later point, if we want to change the pattern that the formatter object uses, we can invoke the applyPattern method. Figure 3.6 describes these methods."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="The pattern defined by the string that is passed to the DecimalFormat constructor can get fairly elaborate. Various symbols are used to represent particular formatting guidelines. The pattern defined by the string '0.###', for example, indicates that at least one digit should be printed to the left of the decimal point and should be a zero if the integer portion of the value is zero. It also indicates that the fractional portion of the value should be rounded to three digits."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="This pattern is used in the CircleStats program, shown in Listing 3.5, which reads the radius of a circle from the user and that computes the circle’s area"
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image55"
                android:layout_gravity="center" />

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:src="@drawable/image56"
                android:layout_gravity="center" />

            (*Note: ADD SPACE HERE)

            <me.biubiubiu.justifytext.library.JustifyTextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="and circumference. Trailing zeros, such as in the circle’s area of 78.540, are not printed using this pattern."
                android:textColor="#000000"
                android:textSize="18sp"
                android:layout_margin="16dp"/>















        </LinearLayout>
    </ScrollView>
    </LinearLayout>